<!doctype html>
<html lang="en">
  <head>
	<meta name="generator" content="Hugo 0.55.5" />
    <meta charset="utf-8">
<title>GADTs in Scala</title>


<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/gadt-presentation/reveal-js/css/reveal.css"><link rel="stylesheet" href="/gadt-presentation/reveal-js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="/gadt-presentation/highlight-js/default.min.css">
    
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
  
<section>

<h2 id="compile-time-scaffolding-in-scala-w-gadts">Compile Time Scaffolding in Scala w/ GADTs</h2>

<ul>
<li>Author: Travis Stevens</li>
<li>Twitter: @OleTraveler</li>
<li>Slides: <a href="https://oletraveler.github.io/bones-presentation/">https://oletraveler.github.io/bones-presentation/</a><br />

<ul>
<li>or <a href="https://bit.ly/2J9O5i1">https://bit.ly/2J9O5i1</a>
<br />
<br /></li>
</ul></li>
</ul>

<p><img src="logo-teal.svg" alt="logo-teal" /></p>

</section><section>

<h2 id="talk-outline">Talk  Outline</h2>

<ul>
<li>GADT Basics</li>
<li>GADTs w/ HList</li>
<li>Validation</li>
<li>Describing REST endpoints</li>
<li>Demo</li>
<li>&lt;Ctrl-D&gt;</li>
</ul>

</section><section>

<h2 id="objectives">Objectives</h2>

<ul>
<li>Learn about GADTs and Interpreters

<ul>
<li>Utilize this pattern in your application</li>
</ul></li>
<li>Learn about the Bones project &ndash; I am looking for feedback

<ul>
<li>Goal is to cut down on boilerplate for REST endpoints</li>
</ul></li>
</ul>

</section><section>

<h2 id="what-is-scaffolding">What is Scaffolding</h2>

<ul>
<li>Hijacked the term from Ruby

<ul>
<li>Auto generation of a simple set of a model, views and controller usually for a single table.</li>
</ul></li>
<li>In Scala

<ul>
<li>Auto generate Type Classes or Functions based on a schema.</li>
</ul></li>
</ul>

</section><section>

<h2 id="what-are-gadts">What are GADTs</h2>

<p>Generalized Algebraic Data Types</p>

<ul>
<li>Aliases

<ul>
<li>Guarded Recursive Data Type</li>
<li>First-class Phantom Type</li>
<li>Free Applicative (cata)</li>
<li>Fixed-point types (Generalization of Recursion - cata++)<br /></li>
</ul></li>
<li>Data Structure

<ul>
<li>Algebra</li>
</ul></li>
<li>Interpreter

<ul>
<li>Transforming the Data Structure into another Data Structure</li>
</ul></li>
</ul>

</section><section>

<p>Algebra</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case object StringData extends KvpValue[String]

case object IntData extends KvpValue[Int]

case class OptionalData[B](b: KvpValue[B]) extends KvpValue[Option[B]]

case class TupleData[E1,E2]( e1: KvpValue[E1], e2: KvpValue[E2]) extends KvpValue[(E1,E2)]
</code></pre>

</section><section>

<p>Algebra</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case object StringData extends KvpValue[String]

case object IntData extends KvpValue[Int]

case class OptionalData[B](b: KvpValue[B]) extends KvpValue[Option[B]]

case class TupleData[E1,E2]( e1: KvpValue[E1], e2: KvpValue[E2]) extends KvpValue[(E1,E2)]
</code></pre>

<p>Usage</p>

<pre><code class="language-scala">val x: KvpValue[(Int,Int)] = TupleData(IntData, IntData)
</code></pre>

</section><section>

<p>Algebra</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case object StringData extends KvpValue[String]

case object IntData extends KvpValue[Int]

case class OptionalData[B](b: KvpValue[B]) extends KvpValue[Option[B]]

case class TupleData[E1,E2]( e1: KvpValue[E1], e2: KvpValue[E2]) extends KvpValue[(E1,E2)]
</code></pre>

<p>Usage</p>

<pre><code class="language-scala">val x: KvpValue[Option[(Int,Int)]] =
  OptionalData(
    TupleData(IntData, IntData)
  )
</code></pre>

</section><section>

<p>Algebra</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case object StringData extends KvpValue[String]

case object IntData extends KvpValue[Int]

case class OptionalData[B](b: KvpValue[B]) extends KvpValue[Option[B]]

case class TupleData[E1,E2]( e1: KvpValue[E1], e2: KvpValue[E2]) extends KvpValue[(E1,E2)]
</code></pre>

<p>Usage</p>

<pre><code class="language-scala">val x: KvpValue[(Option[(Int,Int)], Option[Int])] =
  TupleData(
    OptionalData(
      TupleData(IntData, IntData)
    ),
    OptionalData(IntData)
  )
</code></pre>

</section><section>

<p>Algebra</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case object StringData extends KvpValue[String]

case object IntData extends KvpValue[Int]

case class OptionalData[B](b: KvpValue[B]) extends KvpValue[Option[B]]

case class TupleData[E1,E2]( e1: KvpValue[E1], e2: KvpValue[E2]) extends KvpValue[(E1,E2)]
</code></pre>

<p>Usage</p>

<pre><code class="language-scala">val x: KvpValue[(String,(Option[(Int,Int)], Option[Int]))] =
    TupleData( StringData,
      TupleData(
        OptionalData(
          TupleData( 
            IntData, IntData
          ),
        ),
        OptionalData(IntData)
      )
    )
</code></pre>

</section><section>

<p>Algebra</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case object StringData extends KvpValue[String]

case object IntData extends KvpValue[Int]

case class OptionalData[B](b: KvpValue[B]) extends KvpValue[Option[B]]

case class TupleData[E1,E2]( e1: KvpValue[E1], e2: KvpValue[E2]) extends KvpValue[(E1,E2)]
</code></pre>

<p>Compiler keeps track fo the type</p>

<pre><code class="language-scala">scala&gt; val x =
     |     TupleData( StringData,
     |       TupleData(
     |         OptionalData(
     |           TupleData( 
     |             IntData, IntData
     |           ),
     |         ),
     |         OptionalData(IntData)
     |       )
     |     )
x: TupleData[String,(Option[(Int, Int)], Option[Int])] = TupleData(StringData,TupleData(OptionalData(TupleData(IntData,IntData)),OptionalData(IntData)))
</code></pre>

</section><section>

<p>Example: Parsing Key Value Pairs</p>

</section><section>

<p>Example: Parsing Key Value Pairs</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case class StringData(key: String)  extends KvpValue[String]

case class IntData(key: String)  extends KvpValue[Int]

case class OptionalData[B](optional: KvpValue[B]) extends KvpValue[Option[B]]

case class TupleData[E1,E2](e1: KvpValue[E1], e2: KvpValue[E2]) extends KvpValue[(E1,E2)]
</code></pre>

</section><section>

<p>Building our Schema</p>

<pre><code class="language-scala">scala&gt; val waterfallSchema = 
     |   TupleData( StringData(&quot;name&quot;),
     |     TupleData(
     |       OptionalData( 
     |         TupleData( 
     |           IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;))),
     |       OptionalData(IntData(&quot;height&quot;))
     |     )
     |   )
waterfallSchema: TupleData[String,(Option[(Int, Int)], Option[Int])] = TupleData(StringData(name),TupleData(OptionalData(TupleData(IntData(latitude),IntData(longitude))),OptionalData(IntData(height))))
</code></pre>

</section><section>

<p>Our Schema</p>

<pre><code class="language-scala">val waterfallSchema = 
  TupleData( StringData(&quot;name&quot;),
    TupleData(
      OptionalData( TupleData( IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;) )),
      OptionalData(IntData(&quot;height&quot;))
  ))
</code></pre>

<p>First Interpreter: Description of the Schema</p>

<pre><code class="language-scala">object DocInterpreter {

 def createDoc[A](kvp: KvpValue[A]): String = {
   kvp match {
     case TupleData(e1,e2) =&gt; s&quot;(${createDoc(e1)} combined with ${createDoc(e2)})&quot;
     case OptionalData(optB) =&gt; s&quot;(${createDoc(optB)} which is optional)&quot;
     case StringData(key) =&gt; s&quot;a String with key ${key}&quot;
     case IntData(key) =&gt; s&quot;an Int with key ${key}&quot;
   }
 } 
}
</code></pre>

</section><section>

<p>Our Schema</p>

<pre><code class="language-scala">val waterfallSchema = 
  TupleData( StringData(&quot;name&quot;),
    TupleData(
      OptionalData( TupleData( IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;) )),
      OptionalData(IntData(&quot;height&quot;))
  ))
</code></pre>

<p>First Interpreter: Description of the Schema</p>

<pre><code class="language-scala">object DocInterpreter {

 def createDoc[A](kvp: KvpValue[A]): String = {
   kvp match {
     case TupleData(e1,e2) =&gt; s&quot;(${createDoc(e1)} combined with ${createDoc(e2)})&quot;
     case OptionalData(optB) =&gt; s&quot;(${createDoc(optB)} which is optional)&quot;
     case StringData(key) =&gt; s&quot;a String with key ${key}&quot;
     case IntData(key) =&gt; s&quot;an Int with key ${key}&quot;
   }
 } 
}
</code></pre>

<pre><code class="language-scala">scala&gt; DocInterpreter.createDoc(waterfallSchema)
res0: String = (a String with key name combined with (((an Int with key latitude combined with an Int with key longitude) which is optional) combined with (an Int with key height which is optional)))
</code></pre>

</section><section>

<p>Our Schema</p>

<pre><code class="language-scala">val waterfallSchema = 
  TupleData( StringData(&quot;name&quot;),
    TupleData(
      OptionalData( TupleData( IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;) )),
      OptionalData(IntData(&quot;height&quot;))
  ))
</code></pre>

<p>Generate JSON: Marshall Interpreter</p>

<pre><code class="language-scala">import argonaut._
object ArgonautMarshall {

  def toJsonFunc[A](kvp: KvpValue[A]): A =&gt; Json = {
    kvp match {
      case t: TupleData[e1,e2] =&gt; {
        val e1F: e1 =&gt; Json = toJsonFunc(t.e1)
        val e2F: e2 =&gt; Json = toJsonFunc(t.e2)
        (tuple: (e1,e2)) =&gt; {
          combine( e1F(tuple._1), e2F(tuple._2))
        }
      }
    }
  }

  def combine(prefix: Json, postfix: Json): Json = ???

}

</code></pre>

<ul>
<li>Note use of type variable</li>
</ul>

</section><section>

<p>Our Schema</p>

<pre><code class="language-scala">val waterfallSchema = 
  TupleData( StringData(&quot;name&quot;),
    TupleData(
      OptionalData( TupleData( IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;) )),
      OptionalData(IntData(&quot;height&quot;))
  ))
</code></pre>

<p>Generate Marshall Interpreter</p>

<pre><code class="language-scala">import argonaut._
object ArgonautMarshall {

  def toJsonFunc[A](kvp: KvpValue[A]): A =&gt; Json = {
    kvp match {
      case o: OptionalData[b] =&gt; {
        val bF: b =&gt; Json = toJsonFunc(o.optional)
        (opt: Option[b]) =&gt; {
          opt match {
            case None =&gt; Json.jEmptyObject
            case Some(a) =&gt; bF(a)
          }
        }
      }    
      
//    case t: TupleData[l,r] =&gt; ???

    }
  }
}
</code></pre>

</section><section>

<p>Our Schema</p>

<pre><code class="language-scala">val waterfallSchema = 
  TupleData( StringData(&quot;name&quot;),
    TupleData(
      OptionalData( TupleData( IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;) )),
      OptionalData(IntData(&quot;height&quot;))
  ))
</code></pre>

<p>Generate Marshall Interpreter</p>

<pre><code class="language-scala">import argonaut._
object ArgonautMarshall {

  def toJsonFunc[A](kvp: KvpValue[A]): A =&gt; Json = {
    kvp match {
      case StringData(key) =&gt; str =&gt; Json.obj( (key, Json.jString(str)) )

       case IntData(key) =&gt; l =&gt; Json.obj( (key, Json.jNumber(l)) )
     
//     case o: OptionalData[b] =&gt; ???

//     case t: TupleData[l,r] =&gt; ???

    }
  }   
}
   
</code></pre>

</section><section>

<p>Our Schema</p>

<pre><code class="language-scala">val waterfallSchema = 
  TupleData( StringData(&quot;name&quot;),
    TupleData(
      OptionalData( TupleData( IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;) )),
      OptionalData(IntData(&quot;height&quot;))
  ))
</code></pre>

<p>Create Function</p>

<pre><code class="language-scala">scala&gt; val waterfallToJson = ArgonautMarshall.toJsonFunc(waterfallSchema)
waterfallToJson: ((String, (Option[(Int, Int)], Option[Int]))) =&gt; argonaut.Json = ArgonautMarshall$$$Lambda$4095/1917932800@393fe8ec
</code></pre>

</section><section>

<p>Our Schema</p>

<pre><code class="language-scala">val waterfallSchema = 
  TupleData( StringData(&quot;name&quot;),
    TupleData(
      OptionalData( TupleData( IntData(&quot;latitude&quot;), IntData(&quot;longitude&quot;) )),
      OptionalData(IntData(&quot;height&quot;))
  ))
</code></pre>

<p>Create Function</p>

<pre><code class="language-scala">scala&gt; val waterfallToJson = ArgonautMarshall.toJsonFunc(waterfallSchema)
waterfallToJson: ((String, (Option[(Int, Int)], Option[Int]))) =&gt; argonaut.Json = ArgonautMarshall$$$Lambda$4095/1917932800@497c44c6
</code></pre>

<p>Pass Data</p>

<pre><code class="language-scala">scala&gt; val dryFalls = ( &quot;Dry Falls&quot;, ( Some( (35, -83) ), Some(80) ))
dryFalls: (String, (Some[(Int, Int)], Some[Int])) = (Dry Falls,(Some((35,-83)),Some(80)))

scala&gt; val waterfallJson = waterfallToJson(dryFalls)
waterfallJson: argonaut.Json = {&quot;name&quot;:&quot;Dry Falls&quot;,&quot;latitude&quot;:35,&quot;longitude&quot;:-83,&quot;height&quot;:80}
</code></pre>

</section><section>

<h2 id="schema">Schema</h2>

<p><img src="data-structure-base.png" alt="data-structure-base" /></p>

</section><section>

<h2 id="runtime-function">Runtime Function</h2>

<p><img src="data-structure.png" alt="data-structure" /></p>

</section><section>

<h2 id="runtime-function-1">Runtime Function</h2>

<p><img src="result.png" alt="result" /></p>

</section><section>

<p>Unmarshall Example</p>

<pre><code class="language-scala">object ArgonautUnmarshall {
  def fromJsonFunc[A](kvp: KvpValue[A]) : Json =&gt; Either[String, A] = {
    kvp match {
      case t: TupleData[e1,e2] =&gt;
        val e1F: Json =&gt; Either[String,e1] = fromJsonFunc(t.e1)   // recurse e1 type
        val e2F: Json =&gt; Either[String,e2] = fromJsonFunc(t.e2)   // recurse e2 type
        json =&gt; {
          val e1Result: Either[String,e1] = e1F(json)  
          val e2Result: Either[String,e2] = e2F(json)
          combineTuple(e1Result,e2Result)
        }
    }
  }

  def combineTuple[B,C](b: Either[String,B], c: Either[String,C]): Either[String, (B,C)] = ???

}
</code></pre>

</section><section>

<p>Unmarshall Example</p>

<pre><code class="language-scala">object ArgonautUnmarshall {
  def fromJsonFunc[A](kvp: KvpValue[A]) : Json =&gt; Either[String, A] = {
    kvp match {
      case op: OptionalData[b] =&gt;
        val valueB: Json =&gt; Either[String,b] = fromJsonFunc(op.optional) // recurse
        json =&gt; {
          valueB(json) match {
            case Left(_) =&gt; Right(None)
            case Right(x) =&gt; Right(Some(x))
          }
        }
//    case t: TupleData[l,r] =&gt; ???        
    }
  }
}
</code></pre>

</section><section>

<p>Unmarshall Example</p>

<pre><code class="language-scala">object ArgonautUnmarshall {
  def fromJsonFunc[A](kvp: KvpValue[A]) : Json =&gt; Either[String, A] = {
    kvp match {
      case StringData(key) =&gt; json =&gt;
        findField(key, json).flatMap(_._2.string).toRight(s&quot;String Not Found ${key}&quot;)
      case IntData(key) =&gt; json =&gt;
        findField(key, json).flatMap(_._2.number).flatMap(_.toInt)
          .toRight(s&quot;Int Not Found ${key}&quot;)
//    case t: TupleData[b,c] =&gt; ???
//    case op: OptionalData[b] =&gt; ???
    }
  }

  def findField(key: String, json: Json) : Option[JsonAssoc] = {
    json.obj.flatMap(_.toList.find(_._1 == key))
  }

}
</code></pre>

<p><details class="notes"><summary>?</summary>
 <p>
*
* Either is required in case the input Json doesn&rsquo;t conform to our specification.
* For the marshall example, we didn&rsquo;t need Either because the compile enforsed the our type conformed to the schema.
</p>
</details></p>

</section><section>

<p>JSON to Data (full circle)</p>

<pre><code class="language-scala">scala&gt; waterfallJson
res1: argonaut.Json = {&quot;name&quot;:&quot;Dry Falls&quot;,&quot;latitude&quot;:35,&quot;longitude&quot;:-83,&quot;height&quot;:80}

scala&gt; ArgonautUnmarshall.fromJsonFunc(waterfallSchema)(waterfallJson)
res2: Either[String,(String, (Option[(Int, Int)], Option[Int]))] = Right((Dry Falls,(Some((35,-83)),Some(80))))
</code></pre>

</section><section>

<p>2 Steps: Interpret, Run</p>

<pre><code class="language-scala">          case op: OptionalData[b] =&gt;

            // This Code is evaluated before returning the function
            // and is therefor only executed once per schema begin interpreted
            val valueB = fromJsonFunc(op.optionalKvpValue)

            // This function is executed many times,
            // one for each data transformation
            json =&gt; {
              valueB(json) match {
                case Left(_) =&gt; Right(None)
                case Right(x) =&gt; Right(Some(x))
              }
            }
</code></pre>

</section><section>

<h2 id="gadt-recap">GADT Recap</h2>

<ul>
<li>As the data structure grows, the type is maintained</li>
<li>Interpreters are recursive, but may result in non-recursive data structure</li>
<li>Created both Documentation and Runtime Interpreter for GADT</li>
</ul>

<p><img src="waterfalls/discovery-falls.jpg" alt="data-structure" /></p>

</section><section>

<h2 id="improvements-to-our-implementation">Improvements to our implementation</h2>

<ul>
<li>Current implementation does not allow for hierarchical data</li>
<li>Tuples are clunky (and limited to 22 values)</li>
<li>We want Hierarchical case classes</li>
</ul>

<pre><code class="language-scala">case class Location(latitude: Int, longitude: Int)
case class Waterfall(name: String, location: Option[Location], height: Option[Int])
</code></pre>

</section><section>

<h2 id="shapeless-hlist-quick-overview">Shapeless HList - Quick Overview</h2>

<p>Example Heterogeneous List</p>

<pre><code class="language-scala">scala&gt; //tuple
     | val waterfallTuple = ( &quot;Dry Falls&quot;, ( Some( (35, -83) ), Some(80) ))
waterfallTuple: (String, (Some[(Int, Int)], Some[Int])) = (Dry Falls,(Some((35,-83)),Some(80)))

scala&gt; //HList
     | val waterfallHList = &quot;Dry Falls&quot; :: Some( 35 :: -83 :: HNil ) :: Some(80) :: HNil
waterfallHList: String :: Some[Int :: Int :: shapeless.HNil] :: Some[Int] :: shapeless.HNil = Dry Falls :: Some(35 :: -83 :: HNil) :: Some(80) :: HNil
</code></pre>

</section><section>

<p>//</p>

<p>Concatenate HLists of arbitrary sizes</p>

<pre><code class="language-scala">val prefix = &quot;Dry Falls&quot; :: Some( 35 :: -83 :: HNil) :: HNil
val suffix = Some(80) :: HNil
</code></pre>

<pre><code class="language-scala">scala&gt; prefix ::: suffix
res2: String :: Some[Int :: Int :: shapeless.HNil] :: Some[Int] :: shapeless.HNil = Dry Falls :: Some(35 :: -83 :: HNil) :: Some(80) :: HNil
</code></pre>

</section><section>

<p>Concatenate HLists of arbitrary sizes</p>

<pre><code class="language-scala">val prefix = &quot;Dry Falls&quot; :: Some( 35 :: -83 :: HNil) :: HNil
val suffix = Some(80) :: HNil
</code></pre>

<pre><code class="language-scala">scala&gt; prefix ::: suffix
res3: String :: Some[Int :: Int :: shapeless.HNil] :: Some[Int] :: shapeless.HNil = Dry Falls :: Some(35 :: -83 :: HNil) :: Some(80) :: HNil
</code></pre>

</section><section>

<p>Arbitrarily split an HList</p>

<pre><code class="language-scala">val waterfallHlist = &quot;Dry Falls&quot; :: Some( 35 :: -83 :: HNil ) :: Some(80) :: HNil
val split = Split[String::Option[Int::Int::HNil]::Option[Int]::HNil, Nat._2]
</code></pre>

</section><section>

<p>Arbitrarily split an HList</p>

<pre><code class="language-scala">val waterfallHlist = &quot;Dry Falls&quot; :: Some( 35 :: -83 :: HNil ) :: Some(80) :: HNil
val split = Split[String::Option[Int::Int::HNil]::Option[Int]::HNil, Nat._2]
</code></pre>

<pre><code class="language-scala">scala&gt; split(waterfallHlist)
res4: split.Out = (Dry Falls :: Some(35 :: -83 :: HNil) :: HNil,Some(80) :: HNil)
</code></pre>

</section><section>

<p>Conversion HList to/from Case Classes</p>

<pre><code class="language-scala">  case class Location(latitude: Int, longitude: Int)
  case class Waterfall(name: String, location: Option[Location], height: Option[Int])

  val genLocation = Generic[Location]
  val genWaterfall = Generic[Waterfall]
</code></pre>

<pre><code class="language-scala">scala&gt;     genWaterfall.to _
res5: Waterfall =&gt; genWaterfall.Repr = $$Lambda$4275/439184603@71e7e131

scala&gt;     genWaterfall.from _
res6: genWaterfall.Repr =&gt; Waterfall = $$Lambda$4276/1618502020@19cad392
</code></pre>

</section><section>

<p>Conversion HList to/from Case Classes</p>

<pre><code class="language-scala">  case class Location(latitude: Int, longitude: Int)
  case class Waterfall(name: String, location: Option[Location], height: Option[Int])

  val genLocation = Generic[Location]
  val genWaterfall = Generic[Waterfall]
</code></pre>

<pre><code class="language-scala">  val dryFallsHList = &quot;Dry Falls&quot; :: Some( 35 :: -83 :: HNil ) :: Some(80) :: HNil
  val dryFallsLocation: String :: Option[Location] :: Option[Int] :: HNil = dryFallsHList.head :: dryFallsHList.tail.head.map(genLocation.from) :: dryFallsHList.tail.tail.head :: dryFallsHList.tail.tail.tail
</code></pre>

<pre><code class="language-scala">scala&gt;    val waterfall = genWaterfall.from(dryFallsLocation)
waterfall: Waterfall = Waterfall(Dry Falls,Some(Location(35,-83)),Some(80))

scala&gt;    val waterfallHlist = genWaterfall.to(waterfall)
waterfallHlist: genWaterfall.Repr = Dry Falls :: Some(Location(35,-83)) :: Some(80) :: HNil
</code></pre>

</section><section>

<h2 id="hlist">HList ++</h2>

<ul>
<li>Split and Concat are provided by Shapeless

<ul>
<li>Captured using implicit when building GADT data structures</li>
<li>No Extra Coding</li>
</ul></li>
<li>Associative<br /></li>
</ul>

<h2 id="hlist-1">HList &ndash;</h2>

<ul>
<li>Oddities Pattern Matching with Types

<ul>
<li>currently using <code>asInstanceOf[h]</code> as a work around</li>
<li>other work around using type classes with implicits</li>
<li>needs further understanding</li>
</ul></li>
</ul>

</section><section>

<h2 id="refactor-kvpvalue">Refactor KvpValue</h2>

<ul>
<li>Two Algebras

<ul>
<li><code>KvpHList[H&lt;:HList,N&lt;:Nat]</code>

<ul>
<li>Groups 0 or more key value pairs (Json Object)</li>
<li>Mirrors HList functionality for prepend/concat</li>
<li>Guarantee that head of non nil list will have a key/value class

<ul>
<li><code>KeyValueDefinition(key: String, kvp: KvpValue)</code></li>
</ul></li>
<li>Type Parameter will track the Type</li>
</ul></li>
<li><code>KvpValue[A]</code>

<ul>
<li>Remove key from Primitives</li>
<li>Remove TupleData type</li>
<li>Add a type representing the conversion from KvpHList to a case class</li>
<li>Interpreter result is case class, not HList</li>
</ul></li>
<li>Two interpreters which recursively call each other (mutual recursion)</li>
</ul></li>
</ul>

</section><section>

<p>Refactored KvpValue</p>

<pre><code class="language-scala">sealed abstract class KvpValue[A]

case object StringData extends KvpValue[String]

case object IntData extends KvpValue[Int]

case class OptionalData[B](optionalKvpValue: KvpValue[B]) extends KvpValue[Option[B]]

case class KvpConvertData[H&lt;:HList, N&lt;:Nat, A](kvpHList: KvpHList[H,N], fha: H =&gt; A, fah: A =&gt; H) extends KvpValue[A]
</code></pre>

</section><section>

<p>Key/Value class</p>

<pre><code class="language-scala">case class KeyValueDefinition[A](key: String, kvpValue: KvpValue[A])
</code></pre>

</section><section>

<p>KvpHList</p>

<pre><code class="language-scala">sealed abstract class KvpHList[H &lt;: HList, N &lt;: Nat]
</code></pre>

</section><section>

<p>KvpHList</p>

<pre><code class="language-scala">sealed abstract class KvpHList[H &lt;: HList, N &lt;: Nat]

object KvpNil extends KvpHList[HNil, Nat._0]
</code></pre>

</section><section>

<p>KvpHList</p>

<pre><code class="language-scala">sealed abstract class KvpHList[H &lt;: HList, N &lt;: Nat]

object KvpNil extends KvpHList[HNil, Nat._0]

case class KvpSingleValueHead[A, H &lt;: HList, N &lt;: Nat, OUT &lt;: A :: H]
(
  keyValueDefinition: KeyValueDefinition[A],
  tail: KvpHList[H, N],
  isHCons: IsHCons.Aux[OUT, A, H]
) extends KvpHList[OUT, Succ[N]]
</code></pre>

</section><section>

<p>KvpHList</p>

<pre><code class="language-scala">sealed abstract class KvpHList[H &lt;: HList, N &lt;: Nat]

object KvpNil extends KvpHList[HNil, Nat._0]

case class KvpSingleValueHead[A, H &lt;: HList, N &lt;: Nat, OUT &lt;: A :: H]
(
  keyValueDefinition: KeyValueDefinition[A],
  tail: KvpHList[H, N],
  isHCons: IsHCons.Aux[OUT, A, H]
) extends KvpHList[OUT, Succ[N]]

case class KvpHListHead[HH &lt;: HList, HN &lt;:Nat, HT&lt;:HList, NT &lt;:Nat, HO&lt;:HList, NO&lt;:Nat](
  head: KvpHList[HH, HN],
  tail: KvpHList[HT, NT],
  prepend: Prepend.Aux[HH, HT, HO],
  split: Split.Aux[HO, HN, HH, HT], // analogous: Split.Aux[prepend.OUT,HL,H,T] with lpLength: Length.Aux[H,HL],
) extends KvpHList[HO, NO]
</code></pre>

</section><section>

<h2 id="bizarre-hlist-triangle">Bizarre HList Triangle</h2>

<ul>
<li>KvpValue can contain KvpHList</li>
<li>Head of KvpHList is a KeyValueDefinition</li>
<li>Value in KeyValueDefinition is a KvpValue</li>
</ul>

</section><section>

<p>KvpHList Cons and Concat</p>

<pre><code class="language-scala">    // Enforce head must be a KvpSingleValueHead
    def ::[B](v: KeyValueDefinition[B])(implicit isHCons: IsHCons.Aux[B::HO, B, HO]):
      KvpSingleValueHead[A :: HO, Succ[HN]] = ???

    def :::[HO &lt;: HList, NO &lt;: Nat, HP &lt;: HList, NP &lt;: Nat](prefix: KvpHList[HP, NP])(
      implicit prepend: Prepend.Aux[HP, HH, HO],
      lengthP: Length.Aux[HP, NP],
      length: Length.Aux[HO, NO],
      split: Split.Aux[HO, NP, HP, HH]
    ): KvpHListHead[HP, NP, HH, HP, HO, NO] = ???

</code></pre>

</section><section>

<p>Interpreter - Mutual Recursion</p>

<pre><code class="language-scala">object ArgonautMarshall {
   type Key = String
   def marshallKvpHList[H&lt;:HList,N&lt;:Nat](kvpHList: KvpHList[H,N]): H =&gt; Json = ???
   def marshallKvpValue[A](op: KvpValue[A]): (Key, A) =&gt; Json = ???
}
</code></pre>

</section><section>

<p>Waterfall Example</p>

<pre><code class="language-scala">case class Location(lat: Int, long: Int)
case class Waterfall(name: String, location: Option[Location], height: Option[Int])

val locationHlistSchema =
  KeyValueDefinition(&quot;latitude&quot;, IntData) ::
  KeyValueDefinition(&quot;longitude&quot;, IntData) ::
  KvpNil

val genericLocation = Generic[Location]
val locationSchema = KvpConvertData(locationHlistSchema, genericLocation.from, genericLocation.to)

val waterfallHlistSchema =
  KeyValueDefinition(&quot;name&quot;, StringData) ::
  KeyValueDefinition(&quot;location&quot;, OptionalData(locationSchema)) ::
  KeyValueDefinition(&quot;height&quot;, OptionalData(IntData)) ::
  KvpNil

val genericWaterfall = Generic[Waterfall]
</code></pre>

<pre><code class="language-scala">scala&gt;   val waterfallSchema = KvpConvertData(waterfallHlistSchema, genericWaterfall.from, genericWaterfall.to)
waterfallSchema: slides.HListSlides.KvpConvertData[slides.HListSlides.genericWaterfall.Repr,shapeless.Succ[shapeless.Succ[shapeless.Succ[shapeless.Nat._0]]],slides.HListSlides.Waterfall] = KvpConvertData(KvpSingleValueHead(KeyValueDefinition(name,StringData),KvpSingleValueHead(KeyValueDefinition(location,OptionalData(KvpConvertData(KvpSingleValueHead(KeyValueDefinition(latitude,IntData),KvpSingleValueHead(KeyValueDefinition(longitude,IntData),slides.HListSlides$KvpNil$@2162c70c,shapeless.ops.hlist$IsHCons$$anon$156@5530a586),shapeless.ops.hlist$IsHCons$$anon$156@c30e3f2),slides.HListSlides$$$Lambda$4302/1737418396@3a8479d9,slides.HListSlides$$$Lambda$4303/1461474690@d699322))),KvpSingleValueHead(KeyValueDefinition(height,OptionalData(IntData)),slides.HListSlide...
</code></pre>

</section><section>

<h4 id="validation">Validation</h4>

</section><section>

<p><img src="waterfall-validation.png" alt="waterfall" title="Logo Title Text 1" /></p>

<ul>
<li>Short Circuit

<ul>
<li>Converting Data Types</li>
</ul></li>
<li>Accumulate

<ul>
<li>At each KVP Value</li>
<li>Each parallel input<br /></li>
</ul></li>
</ul>

<p><a href="https://dreampuf.github.io/GraphvizOnline/#%0Adigraph%20G%20%7B%0A%0A%20%20subgraph%20cluster_0%20%7B%0A%20%20%20%20style%3Dfilled%3B%0A%20%20%20%20color%3Dlightgrey%3B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%2Ccolor%3Dwhite%5D%3B%0A%20%20%20%20%22Is%20String%22-%3E%20%22Max%2030%22%3B%0A%20%20%20%20%22Is%20String%22%20-%3E%20%22Words%20Only%22%3B%0A%20%20%20%20label%20%3D%20%22Name%22%3B%0A%20%20%7D%0A%20%20%0A%20%20subgraph%20cluster_1%20%7B%0A%20%20%20%20style%3Dfilled%3B%0A%20%20%20%20color%3Dlightgrey%3B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%2Ccolor%3Dwhite%5D%3B%0A%20%20%20%20%22Lat%20Is%20Number%22%20-%3E%20%22Lat%3A%20-90..90%22%3B%0A%20%20%20%20label%20%3D%20%22Latitude%22%3B%0A%20%20%7D%0A%20%20%0A%20%20subgraph%20cluster_2%20%7B%0A%20%20%20%20style%3Dfilled%3B%0A%20%20%20%20color%3Dlightgrey%3B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%2Ccolor%3Dwhite%5D%3B%0A%20%20%20%20%22Lon%20Is%20Number%22%20-%3E%20%22Lon%3A%20-90..90%22%3B%0A%20%20%20%20label%20%3D%20%22Longitude%22%3B%0A%20%20%7D%0A%20%20%0A%20%20subgraph%20cluster_3%20%7B%0A%20%20%20%20style%3Dfilled%3B%0A%20%20%20%20color%3Dlightgrey%3B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%2Ccolor%3Dwhite%5D%3B%0A%20%20%20%20%22Height%20Is%20Number%22%20-%3E%20%22Greater%20than%200%22%3B%0A%20%20%20%20%22Height%20Is%20Number%22%20-%3E%20%22Less%20than%203%2C212%20ft%22%3B%0A%20%20%20%20label%20%3D%20%22Card%20Number%22%3B%0A%20%20%7D%0A%20%20%0A%20%20subgraph%20cluster_4%20%7B%0A%20%20%20%20style%3Dfilled%3B%0A%20%20%20%20color%3Dlightgrey%3B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%2Ccolor%3Dwhite%5D%3B%0A%20%20%20%20%22Lat%3A%20-90..90%22%20-%3E%20%22Is%20in%20WNC%22%3B%0A%20%20%20%20%22Lon%3A%20-90..90%22%20-%3E%20%22Is%20in%20WNC%22%3B%0A%20%20%7D%0A%20%20%0A%20%20subgraph%20cluster_5%20%7B%0A%20%20%20%20style%3Dfilled%3B%0A%20%20%20%20color%3Dlightgrey%3B%0A%20%20%20%20node%20%5Bstyle%3Dfilled%2Ccolor%3Dwhite%5D%3B%0A%20%20%20%20%22Max%2030%22%20-%3E%20%22Waterfall%22%3B%0A%20%20%20%20%22Words%20Only%22%20-%3E%20%22Waterfall%22%3B%0A%20%20%20%20%22Is%20in%20WNC%22%20-%3E%20%22Waterfall%22%3B%0A%20%20%20%20%22Greater%20than%200%22%20-%3E%20%22Waterfall%22%3B%0A%20%20%20%20%22Less%20than%203%2C212%20ft%22%20-%3E%20%22Waterfall%22%0A%20%20%7D%0A%20%20%0A%20%20%0A%20%20%0A%20%20%0A%20%20JSON%20-%3E%20%22Is%20String%22%3B%0A%20%20JSON%20-%3E%20%22Lat%20Is%20Number%22%3B%0A%20%20JSON%20-%3E%20%22Lon%20Is%20Number%22%3B%0A%20%20JSON%20-%3E%20%22Height%20Is%20Number%22%3B%0A%0A%20%20JSON%20%5Bshape%3DMdiamond%5D%3B%0A%7D">GV</a></p>

</section><section>

<p>Validation Using a GADT State Of Mind</p>

<pre><code class="language-scala">trait ValidationOp[T]

case class MaxLength(max: Int) extends ValidationOp[String]
</code></pre>

</section><section>

<h4 id="validation-interpreter">Validation Interpreter</h4>

<pre><code class="language-scala">def isValid[A](op: ValidationOp[A]): A =&gt; Either[String, A] = {
  op match {
    case MaxLength(max) =&gt; 
      str =&gt; if (str.length &lt;= max) Right(str) else Left(s&quot;$str is greater than $max&quot;)
  }
}
def doc[A](op: ValidationOp[A]): String = {
  op match {
    case MaxLength(max) =&gt; s&quot;maximum of $max&quot; 
  }
}
</code></pre>

</section><section>

<h4 id="accumulate-errors-in-primitive-types">Accumulate errors in Primitive Types</h4>

<pre><code class="language-scala">case class StringData(validationOps: ValidationOp[String]) extends KvpValue[String]

def toJsonFunction[A](kvpValue: KvpValue[A]): (Key, Json) =&gt; Either[NonEmptyList[String],A] = {
kvpValue match {
  case StringData(validations) =&gt;
    (key, json) =&gt;
      for {
        jsonString &lt;- json.field(key).toRight(NonEmptyList.one(s&quot;Field with key $key not found.&quot;))
        str &lt;- jsonString.string.toRight(NonEmptyList.one(s&quot;Field with key $key is not a String&quot;))
        validStr &lt;- applicativeCombine(validations.map(validationOp =&gt; isValid(validationOp).apply(str)))
      } yield validStr
  }
}

</code></pre>

</section><section>

<h4 id="describing-rest-endpoints">Describing REST endpoints</h4>

<ul>
<li>Input</li>
<li>Output</li>
<li>Error
<br /></li>
</ul>

</section><section>

<p>CRUD Algebra</p>

<pre><code class="language-scala">case class Create[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O]) 
case class Read[E,O](err: KvpValue[E], out: KvpValue[O])
case class Update[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O])
case class Delete[E,O](err: KvpValue[E], out: KvpValue[O])
case class Search[E,O](err: KvpValue[E], out: KvpValue[O])
</code></pre>

</section><section>

<p>CRUD Algebra</p>

<pre><code class="language-scala">case class Create[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O]) 
case class Read[E,O](err: KvpValue[E], out: KvpValue[O])
case class Update[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O])
case class Delete[E,O](err: KvpValue[E], out: KvpValue[O])
case class Search[E,O](err: KvpValue[E], out: KvpValue[O])
</code></pre>

<p>Business Logic</p>

<pre><code class="language-scala">def createF[I,E,O]: I =&gt; Either[E,O] = ???
def readF[ID,E,O]: ID =&gt; Either[E,O] = ???
def updateF[ID,I,E,O]: (ID,I) =&gt; Either[E,O] = ???
def delete[ID,E,O]: ID =&gt; Either[E,O] = ???
def findAll[O]: () =&gt; Stream[O] = ???
def search[SP,E,O]: SP =&gt; Either[E,Stream[O]] = ???
</code></pre>

</section><section>

<p>CRUD Algebra</p>

<pre><code class="language-scala">case class Create[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O]) 
case class Read[E,O](err: KvpValue[E], out: KvpValue[O])
case class Update[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O])
case class Delete[E,O](err: KvpValue[E], out: KvpValue[O])
case class Search[E,O](err: KvpValue[E], out: KvpValue[O])
</code></pre>

<p>Business Logic</p>

<pre><code class="language-scala">import cats.effect.IO
def createF[I,E,O]: I =&gt; IO[Either[E,O]] = ???
def readF[ID,E,O]: ID =&gt; IO[Either[E,O]] = ???
def updateF[ID,I,E,O]: (ID,I) =&gt; IO[Either[E,O]] = ???
def delete[ID,E,O]: ID =&gt; IO[Either[E,O]] = ???
def findAll[O]: () =&gt; IO[Stream[O]] = ???
def search[SP,E,O]: SP =&gt; IO[Either[E,Stream[O]]] = ???
</code></pre>

</section><section>

<p>CRUD Algebra</p>

<pre><code class="language-scala">case class Create[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O]) 
case class Read[E,O](err: KvpValue[E], out: KvpValue[O])
case class Update[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O])
case class Delete[E,O](err: KvpValue[E], out: KvpValue[O])
case class Search[E,O](err: KvpValue[E], out: KvpValue[O])
</code></pre>

<p>Business Logic</p>

<pre><code class="language-scala">import scalaz.zio.ZIO
def createF[I,E,O]: I =&gt; ZIO[_, E,O] = ???
def readF[ID,E,O]: ID =&gt; ZIO[_,E,O] = ???
def updateF[ID,I,E,O]: (ID,I) =&gt; ZIO[_,E,O] = ???
def delete[ID,E,O]: ID =&gt; ZIO[_,E,O] = ???
def findAll[O]: () =&gt; ZIO[_,Nothing,Stream[O]] = ???
def search[SP,E,O]: SP =&gt; ZIO[_,E,Stream[O]] = ???
</code></pre>

</section><section>

<h1 id="rest-interpreter">REST Interpreter</h1>

<ul>
<li>Take care of the Plumbing

<ul>
<li>Use interpreters to marshall/unmarhsall data</li>
<li>Use interpreters to valiate data</li>
<li>Encoding Routes</li>
<li>What to use as an ID</li>
<li>Roles</li>
<li>Extract data for a search

<ul>
<li>parameters</li>
<li>page limits and sizing
<br />
<br /></li>
</ul></li>
</ul></li>
</ul>

</section><section>

<pre><code class="language-scala">
  type Key = String
  case class Create[I,E,O](in: KvpValue[I], err: KvpValue[E], out: KvpValue[O])
  def toJsonFunc[A](op: KvpValue[A]): A =&gt; Array[Byte] = ???
  def fromJsonFunc[A](op: KvpValue[A]): Array[Byte] =&gt; Either[String,A] = ???

  def post[CI, CE, CO](c: Create[CI,CE,CO],
                       path: String): (CI =&gt; IO[Either[CE, CO]]) =&gt; HttpRoutes[IO] = { createF =&gt;

    val inF: Array[Byte] =&gt; Either[String,CI] = fromJsonFunc(c.in)
    val outF: CO =&gt; Array[Byte] = toJsonFunc(c.out)
    val errF: CE =&gt; Array[Byte] = toJsonFunc(c.err)


    HttpRoutes.of[IO] {
      case req@Method.POST -&gt; Root / path =&gt; {
        val result: EitherT[IO, IO[Response[IO]], IO[Response[IO]]] = for {
          body &lt;- EitherT[IO, IO[Response[IO]], Array[Byte]] {
            req.as[Array[Byte]].map(Right(_))
          }
          in &lt;- EitherT.fromEither[IO] {
            inF(body).left.map(x =&gt; BadRequest())                  // &lt;---- input conversion to CI
          }
          out &lt;- EitherT[IO, IO[Response[IO]], CO] {
            createF(in)                                            // &lt;---- business logic
              .map(_.left.map(ce =&gt; {
              val out = errF(ce)                                   // &lt;----- error case output conversion from CE
              InternalServerError(out,
                Header(&quot;Content-Type&quot;, &quot;text/json&quot;))
            }))
          }
        } yield {
          Ok(outF(out), Header(&quot;Content-Type&quot;, &quot;text/json&quot;))        // &lt;----- output conversion from CO
        }
        result.value.flatMap(_.merge)
      }
    }
  }

</code></pre>

</section><section>

<h2 id="collection-of-interpreters">Collection of interpreters</h2>

<ul>
<li>Circe, Argonaut, LiftJson, Bson, Protobuff

<ul>
<li>marshall and unmarshall</li>
</ul></li>
<li>Documentation

<ul>
<li>Swagger Doc &amp; Protobuf Definition Files</li>
</ul></li>
<li>DB

<ul>
<li>Basic ORM, DB Schema Gen (POC)</li>
</ul></li>
<li>ReactJS

<ul>
<li>Create ES2018 React Components (POC, not Scala.js)</li>
</ul></li>
<li>Http

<ul>
<li>Http4s HttpRoutes</li>
<li>Unfiltered ResponseFunction</li>
</ul></li>
<li>Scalacheck Generators<br /></li>
<li>BYOI
<br /></li>
</ul>

</section><section>

<h1 id="demo">DEMO</h1>

</section><section>

<h4 id="ctrl-d"><Ctrl-D></h4>

<ul>
<li>Extend functionality using coproduct</li>
<li>Relationship to Free Applicative</li>
<li>Encapsulation

<br /></li>
</ul>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/gadt-presentation/reveal-hugo/object-assign.js></script>

<a href="/gadt-presentation/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">null</script>
<script type="application/json" id="reveal-hugo-page-params">null</script>

<script src="/gadt-presentation/reveal-js/lib/js/head.min.js"></script>
<script src="/gadt-presentation/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  
  var revealHugoDefaults = { 
    width: "100%",
    height: "100%",
    margin: 0,
    minScale: 1,
    maxScale: 1,
    transition: "none"
  };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>

<script type="text/javascript" src="/gadt-presentation/reveal-js/lib/js/classList.js"></script>


<script type="text/javascript" src="/gadt-presentation/reveal-js/plugin/markdown/marked.js"></script>

<script type="text/javascript" src="/gadt-presentation/reveal-js/plugin/markdown/markdown.js"></script>

<script type="text/javascript" src="/gadt-presentation/reveal-js/plugin/highlight/highlight.js"></script>

<script type="text/javascript" src="/gadt-presentation/reveal-js/plugin/zoom-js/zoom.js"></script>


<script type="text/javascript" src="/gadt-presentation/reveal-js/plugin/notes/notes.js"></script>



<script type="text/javascript">
if (hljs)
  hljs.initHighlightingOnLoad();
</script>

    
    
  </body>
</html>
